#!/usr/bin/perl

# Get a list of all header files

foreach my $dir (scandir("..")) {
	if (!-d "$dir" || $dir =~ /^\.\.\/\./) { next; }
	foreach my $file (scandir("$dir")) {
		if ($file !~ /\.h$/) { next; }
		push @headerfiles, $file;
	}
}

# Collect a list of class names

foreach my $file (@headerfiles) {
	open FILE, $file;
	while (!eof(FILE)) {
		$line = <FILE>;
		if ($line =~ /class_create \(([^, ]+)\s*,\s*([^ )]+)/i) {
			push @classes, $1;
			$classParent{$1} = $2;
		}
		if ($line =~ /define_struct \(([^\)]+)\)/i) {
			push @structs, $1;
			$is_struct{$1} = 1;
		}
	}
	close FILE;
}

%typemap = (
    #  C  	 =>   C#
	'void' => 'void',
	'unsigned char' => 'byte',
	'char' => 'sbyte',
	'short' => 'int',
	'int' => 'int',
	'long' => 'int',
	'unsigned long' => 'uint',
	'float' => 'float',
	'double' => 'double',
	'string' => 'string',  # used specially
	'IntPtr' => 'IntPtr',  # used specially
	);
	
push @classes, keys(%typemap);
foreach my $class (values(%typemap)) { $isNativeType{$class} = 1; }

# so that we recognize the names, but we won't generate the wrappers
@badtypes = (FILE, Thing, Any, MelderFile, MelderDir,
	Command, Data_Description, Widget, Editor,
	Graphics, Graphics_Viewport, Graphics_Link, GraphicsPostscript, GraphicsScreen,
	dcomplex);
foreach my $class (@badtypes) { $isBadType{$class} = 1; }
	
push @classes, @badtypes;

# Find function definitions

$classes_pattern = join("|", @classes, @structs);

foreach my $file (@headerfiles) {
	open FILE, $file;
	while (!eof(FILE)) {
		$line = <FILE>; chop $line;
		$line =~ s/\/\*.*?\*\///g;
		$original = $line;
		if ($line =~ s/^($classes_pattern) (($classes_pattern)s?_(\w\S*)) \(//i) {
			$return_type = $1;
			$export_name = $2;
			$class = $3;
			$method = $4;
			
			$hasthis = 0;
			$punc = '';
			if ($line =~ s/^$class me([,)])//) {
				$hasthis = 1;
				$punc = $1;
			}
			
			@argtypes = ();
			@argnames = ();
			
			$bad = 0;
			if ($isBadType{$return_type}) { $bad = 1; }
			
			while (1) {
				while ($line =~ s/^\s*((const )?($classes_pattern)((\**) | (\**) *)(\w+)(\s*?\[\])?|I|thou|void)\s*([,)])//) {
					$param_type = $3;
					$param_asterisks = $5 . $6;
					$param_name = $7;
					$param_array = $8;
					$punc = $9;
					if ($param_type eq '') { $param_type = 'object'; $param_name = $1; }
					if ($param_name eq 'void') { next; }

					if ($param_type eq 'char' && $param_asterisks =~ s/^\*//) { $param_type = "string"; }

					if (!$typemap{$param_type} && !$classParent{$param_type}) { $bad = 1; }
					if ($typemap{$param_type}) { $param_type = $typemap{$param_type}; }
					if ($isBadType{$param_type}) { $bad = 1; }

					if ($param_name eq 'new') { $param_name .= 'value'; }
					if ($param_name eq 'out') { $param_name .= 'value'; }
					if ($param_name eq 'ref') { $param_name .= 'value'; }
					if ($param_name eq 'string') { $param_name .= 'value'; }
					
					# for now, we won't support *'s and []'s
					if ($param_asterisks ne '' || $param_array ne '') { $bad = 1; }

					push @argtypes, "$param_type$param_asterisks$param_array";
					push @argnames, $param_name;
				}
				if ($punc eq ',' && $line =~ /^\s*$/) {
					$line = <FILE>; chop $line;
					$line =~ s/\/\*.*?\*\///g;

					my $test1 = quotemeta('int (*playCallback) (void *playClosure, int phase, double tmin, double tmax, double t), void *playClosure');
					$line =~ s/$test1/IntPtr playCallback, IntPtr playClosure/;

					$original .= $line;
					$punc = '';
				} elsif ($punc eq ')') {
					last;
				} else {
					if ($line =~ /^\)/) { last; }
					warn "Could not parse [$punc] '$line' while parsing '$original'.";
					$bad = 1;
					last;
				}
			}
			
			if ($typemap{$return_type}) { $return_type = $typemap{$return_type}; }
			
			if ($bad) { next; }
			
			push @{ $methods{$class} }, { export_name => $export_name, name => $method, instance => $hasthis,
				return_type => $return_type, argtypes => [@argtypes], argnames => [@argnames] };
		}
	}
	close FILE;
}

# base class

print <<EOF;
// This file is autogenerated.  Do not edit!

using System;
using System.Runtime.InteropServices;

namespace PraatTypes {

public abstract class Thing {
	internal IntPtr handle;
	public Thing(IntPtr handle) { this.handle = handle; }
	
	[DllImport("__Internal")]
	static extern void _Melder_free (ref IntPtr pointer);
	~Thing() {
		destroy();
	}
	
	public void destroy() {
		if (handle != IntPtr.Zero) {
			_Melder_free(ref handle);
			handle = IntPtr.Zero;
		}
	}
}

EOF

# generate classes

foreach my $class (keys(%classParent)) {
	if ($isBadType{$class}) { next; }

	$funcs = WriteMethods($class, 0);
	
	if ($classParent{$class} eq 'Data') { $classParent{$class} = 'Thing'; }
	if ($isBadType{$classParent{$class}}) { $classParent{$class} = 'Thing'; }

	print <<EOF;
public class $class : $classParent{$class} {
	
	internal $class(IntPtr handle) : base(handle) { }

$funcs
}
EOF
}

# static classes

print <<EOF;

public class PraatStaticMethods {

EOF

foreach my $class (keys(%classParent)) {
	if ($isBadType{$class}) { next; }

	$funcs = WriteMethods($class, 1);
	$funcs =~ s/\n/\n\t/g;
	
	print <<EOF;
	public static_$class $class = new static_$class();
	
	public class static_$class {
	$funcs
	}
EOF

}

print <<EOF;
}
EOF

print <<EOF;

}
EOF

sub scandir {
	opendir D, "$_[0]";
	my @ret = readdir(D);
	closedir D;
	foreach my $x (@ret) { $x = $_[0] . "/" . $x; }
	return @ret;
}


sub WriteMethods {
	my $class = shift;
	my $staticOnly = shift;
	
	my %seenmethods;

	my $funcs;
	foreach my $method (@{ $methods{$class} }) {
		my $name = $$method{name};
		
		if ($seenmethods{$name}) {
			warn "$class::$name seems to be defined twice.";
			next;
		}
		$seenmethods{$name} = 1;
		
		my @csargs = ();
		my @cargs = ();
		my @argnames = ();
		for ($i = 0; $i < scalar(@{ $$method{argnames} }); $i++) {
			my $type = $$method{argtypes}[$i];
			my $name = $$method{argnames}[$i];
			if ($type ne "IntPtr") { push @csargs, "$type $name"; }
			
			my $nativetype = $type;
			if (!$isNativeType{$type}) { $nativetype = "IntPtr"; }
			push @cargs, "$nativetype $name";
			
			if (!$isNativeType{$type}) { $name = "$name.handle"; }
			if ($type eq "IntPtr") { $name = "IntPtr.Zero"; }
			push @argnames, $name;
		}
		
		my $cflags = "static ";
		if ($staticOnly) { $cflags = ""; }
		
		my $return = "return ";
		if ($$method{return_type} eq 'void') { $return = ""; }
		
		my $return_type = $$method{return_type};
		my $c_return_type = $$method{return_type};
		
		my $ctor = '';
		
		if ($$method{instance}) {
			$cflags = "new";
			unshift @cargs, "IntPtr me";
			unshift @argnames, "handle";
			if ($staticOnly) { next; }
		} else {
			if ($name eq "create") {
				$name = $class;
				$cflags = '';
				$return = 'this.handle =';
				$return_type = '';
				$ctor = ': base(IntPtr.Zero)';
				if ($staticOnly) { next; }
			}
		}
		
		my $retclass1;
		my $retclass2;
		if ($return_type ne '' && !$isNativeType{$return_type}) {
			$retclass1 = "new $return_type (";
			$retclass2 = ")";
		}
		if (!$isNativeType{$c_return_type}) {
			$c_return_type = 'IntPtr';
		}
		
		my $cargs = join(", ", @cargs);
		my $args = join(", ", @csargs);
		my $argnames = join(", ", @argnames);
	
		$funcs .= <<EOF;
	[DllImport("__Internal")]
	static extern $c_return_type $$method{export_name} ($cargs);
	public $cflags $return_type $name ($args) $ctor {
		$return $retclass1 $$method{export_name} ($argnames) $retclass2;
	}

EOF
	}
	
	return $funcs;

}
